disp('   Setting up materials');
disp('   -- Densities ');
md.materials.rho_ice			= 917.;  % (917 is the value used in BedMachine)
md.materials.rho_water		= 1027.; % ocean water (1027 is the value used in BedMachine)
md.materials.rho_freshwater= 1000.; % fresh water
md.constants.g					= 9.81;  % gravitational acceleration

disp('   -- Creating flow law parameters (assume ice is at -10Â°C for now)');
md.materials.rheology_B		= cuffey(273.15 -10)*ones(md.mesh.numberofvertices,1);
md.materials.rheology_n		= 3*ones(md.mesh.numberofelements,1);
md.materials.rheology_law  = 'Cuffey';

%Name and Coordinate system
md.miscellaneous.name='PIG';
md.mesh.epsg=3031;

%NetCdf Loading
disp('   Loading SeaRISE data from NetCDF');
ncdata=[issmdir() 'examples/Data/Antarctica_5km_withshelves_v0.75.nc'];
x1    = ncread(ncdata,'x1');
y1    = ncread(ncdata,'y1');
temp  = ncread(ncdata,'presartm')';
smb   = ncread(ncdata,'presprcp')';
gflux = ncread(ncdata,'bheatflx_fox')';

%Geometry
disp('   Interpolating surface and ice base');
md.geometry.surface = interpBedmachineAntarctica(md.mesh.x,md.mesh.y,'surface','linear',[issmdir() 'examples/Data/BedMachineAntarctica_2020-07-15_v02.nc']);
pos = find(md.geometry.surface<1.e-10| isnan(md.geometry.surface)); % ocean part or rocks	
md.geometry.surface(pos)	= 1.e-10; % set minimum ice surface on the ocean part
md.geometry.bed = interpBedmachineAntarctica(md.mesh.x,md.mesh.y,'bed','linear',[issmdir() 'examples/Data/BedMachineAntarctica_2020-07-15_v02.nc']);
md.geometry.base = zeros(length(md.geometry.bed),1); % initial setup 
% Setting up ice thickness, ice base and grounded ice level set based on the hydrostatic equilibrium
floatation_base				      = md.geometry.surface*md.materials.rho_ice/(md.materials.rho_ice-md.materials.rho_water); % using the corrected surface
pos								      = find(floatation_base<md.geometry.bed); % grounded ice
md.geometry.base(pos)		      = md.geometry.bed(pos);
md.mask.ocean_levelset(pos)		= 1; 
pos								      = find(floatation_base>md.geometry.bed); % floating ice
md.geometry.base(pos)		      = floatation_base(pos);
md.mask.ocean_levelset(pos)		= -1; 
md.geometry.thickness		      = md.geometry.surface-md.geometry.base;
pos								      = find(md.geometry.thickness<1); % dealing with rocks or ocean part
md.geometry.thickness(pos)       = 1.;
md.geometry.surface(pos)	      = md.geometry.thickness(pos)+md.geometry.base(pos);

disp('   Constructing thickness');
md.geometry.thickness=md.geometry.surface-md.geometry.base;

%ensure hydrostatic equilibrium on ice shelf: 
di=md.materials.rho_ice/md.materials.rho_water;

%Get the node numbers of floating nodes
pos=find(md.mask.ocean_levelset<0); 

%apply a flotation criterion on the precedingly defined nodes and
%redefine base and thickness accordingly
md.geometry.thickness(pos)=1/(1-di)*md.geometry.surface(pos);
md.geometry.base(pos)=md.geometry.surface(pos)-md.geometry.thickness(pos);
md.geometry.hydrostatic_ratio=ones(md.mesh.numberofvertices,1); %For Dakota

%Set min thickness to 1 meter
pos0=find(md.geometry.thickness<=1);
md.geometry.thickness(pos0)=1;
md.geometry.surface=md.geometry.thickness+md.geometry.base;
md.geometry.bed=md.geometry.base;
md.geometry.bed(pos)=md.geometry.base(pos)-1000;

%Initialization parameters
disp('   Interpolating temperatures');
md.initialization.temperature=InterpFromGridToMesh(x1,y1,temp,md.mesh.x,md.mesh.y,0)+273.15;
clear temp;

disp('   Loading velocities data from NetCDF');
nsidc_vel=[issmdir() 'examples/Data/Antarctica_ice_velocity.nc'];
xmin    = ncreadatt(nsidc_vel,'/','xmin');
ymax    = ncreadatt(nsidc_vel,'/','ymax');
spacing = ncreadatt(nsidc_vel,'/','spacing');
nx      = double(ncreadatt(nsidc_vel,'/','nx'));
ny      = double(ncreadatt(nsidc_vel,'/','ny'));
velx    = double(ncread(nsidc_vel,'vx'));
vely    = double(ncread(nsidc_vel,'vy'));
% Read coordinates
xmin = strtrim(xmin);  
xmin = str2num(xmin(1:end-2)); 
ymax = strtrim(ymax);  
ymax = str2num(ymax(1:end-2));  
spacing = strtrim(spacing);
spacing = str2num(spacing(1:end-2));  
% Build the coordinates
x2=xmin+(0:1:nx)'*spacing;
y2=(ymax-ny*spacing)+(0:1:ny)'*spacing;

disp('   Set observed velocities')
md.initialization.vx=InterpFromGridToMesh(x2,y2,flipud(velx'),md.mesh.x,md.mesh.y,0);
md.initialization.vy=InterpFromGridToMesh(x2,y2,flipud(vely'),md.mesh.x,md.mesh.y,0);
md.initialization.vz=zeros(md.mesh.numberofvertices,1);
md.initialization.vel=sqrt(md.initialization.vx.^2+md.initialization.vy.^2);
clear velx vely;

disp('   Set Pressure');
md.initialization.pressure=md.materials.rho_ice*md.constants.g*md.geometry.thickness;

%Forcings
disp('   Interpolating surface mass balance');
mass_balance=InterpFromGridToMesh(x1,y1,smb,md.mesh.x,md.mesh.y,0);
md.smb.mass_balance=mass_balance*md.materials.rho_water/md.materials.rho_ice;
clear smb;

disp('   Set geothermal heat flux');
md.basalforcings.geothermalflux=InterpFromGridToMesh(x1,y1,gflux,md.mesh.x,md.mesh.y,0);
clear gflux;

%Friction and inversion set up
disp('   Construct basal friction parameters');
md.friction.coefficient=20*ones(md.mesh.numberofvertices,1);
md.friction.p=ones(md.mesh.numberofelements,1);
md.friction.q=ones(md.mesh.numberofelements,1);

%no friction applied on floating ice
pos=find(md.mask.ocean_levelset<0);
md.friction.coefficient(pos)=0;
md.groundingline.migration='SubelementMigration';

md.inversion=m1qn3inversion();
md.inversion.vx_obs=md.initialization.vx;
md.inversion.vy_obs=md.initialization.vy;
md.inversion.vel_obs=md.initialization.vel;

disp('   Set boundary conditions');
md.basalforcings.floatingice_melting_rate = zeros(md.mesh.numberofvertices,1);
md.basalforcings.groundedice_melting_rate = zeros(md.mesh.numberofvertices,1);
md.thermal.spctemperature                 = md.initialization.temperature;
md.stressbalance.spcvx			= NaN(md.mesh.numberofvertices,1);
md.stressbalance.spcvy			= NaN(md.mesh.numberofvertices,1);
md.stressbalance.spcvz			= NaN(md.mesh.numberofvertices,1);
md.stressbalance.referential	= NaN(md.mesh.numberofvertices,6);
md.stressbalance.loadingforce	= zeros(md.mesh.numberofvertices,3);
md.masstransport.spcthickness	= NaN(md.mesh.numberofvertices,1);
pos = find((md.mask.ice_levelset<0).*(md.mesh.vertexonboundary)); % the contour part of the ice
md.stressbalance.spcvx(pos)	= md.initialization.vx(pos);
md.stressbalance.spcvy(pos)	= md.initialization.vy(pos);
